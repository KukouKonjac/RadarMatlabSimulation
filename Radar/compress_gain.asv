close all; clear; clc;

%% ================= LFM 信号参数 =================
B = 20e6;
T = 100e-6;
u = B / T;
fs = 4 * B;
N = round(T * fs);
t = (0:N-1).' / fs;

%% ================= 雷达参数 =================
Pt = 1e3;
Gt = 30; Gr = 30;
sigma = 1;
Lsys = 1;

k = physconst('Boltzmann');
T0 = 290;
NF = 3;
B_rx = fs;

% 雷达工作频段
c = physconst('LightSpeed');
fc_radar = 10e9;
lambda = c / fc_radar;
B_radar  = 20e6;        % 雷达带宽 20 MHz
f_radar = linspace(fc_radar-B_radar/2, fc_radar+B_radar/2, N);  % 雷达频谱

%% ================= 距离扫描 =================
R_list = linspace(50, 6000, 300);

snr_sig = zeros(size(R_list));

snr_func = zeros(size(R_list));
snr_sig_pre  = zeros(size(R_list));   % 信号级，脉压前
snr_func_pre = zeros(size(R_list));   % 功能级，脉压前

m_pc_eq  = zeros(size(R_list));
R_err    = zeros(size(R_list));

%% ================= 发射信号 & 匹配滤波 =================
s_tx = exp(1j*pi*u*t.^2);
% 匹配滤波器
h = conj(flip(s_tx));
%% ================= Monte Carlo 次数 =================
MC = 50;   % 可调
for i = 1:length(R_list)
    
    snr_sig_pre_acc = 0;
    snr_sig_post_acc = 0;
    m_pc_eq_acc = 0;
    R_err_acc = 0;

    R0 = R_list(i);
    tau = 2*R0/c;
    if tau >= T
        snr_sig(i) = NaN; snr_func(i) = NaN;
        m_pc_eq(i) = NaN; R_err(i) = NaN;
        continue;
    end

    %% -------- 回波信号 --------
    t_eff = t - tau;
    valid = (t_eff >= 0) & (t_eff <= T);

    s_rx_clean = zeros(size(t));
    s_rx_clean(valid) = exp(1j*pi*u*t_eff(valid).^2);  

    %% -------- 雷达方程 --------
    Pr = (Pt*Gt*Gr*lambda^2*sigma)/((4*pi)^3*R0^4*Lsys);
    s_rx_clean = sqrt(Pr)*s_rx_clean;

    for mc = 1:MC
        Pn = k*T0*B_rx*NF;
        noise = sqrt(Pn/2)*(randn(size(t))+1j*randn(size(t)));
        s_rx = s_rx_clean + noise;
    
        %% -------- 脉压前 SNR --------
        snr_pre = max(abs(s_rx_clean).^2) / var(noise);
        % snr_sig_pre(i)  = 10*log10(snr_pre);
        % snr_func_pre(i) = 10*log10(Pr / Pn);
    
    
        % %% -------- 匹配滤波 --------
        y_sig = conv(s_rx_clean, h, 'full');
        % y     = conv(s_rx,       h, 'full');
        % y_n   = conv(noise,      h, 'full');
        % 
        % %% -------- 脉压后 SNR --------
        % [~, idx] = max(abs(y_sig));
        % snr_post = abs(y_sig(idx))^2 / var(y_n);
        % 
        % snr_sig(i) = 10*log10(snr_post);
        % m_pc_eq(i) = snr_post / snr_pre;
    
        %% -------- 匹配滤波 (包含噪声的完整接收信号) --------
        y_total = conv(s_rx, h, 'full'); 
        y_power = abs(y_total).^2; % 计算瞬时功率
        
        %% -------- 信号级 SNR (实测：主瓣/噪声) --------
        [P_peak, k_obs] = max(y_power);
        
        mask = true(size(y_power));
        win_size = round(fs/B * 5); 
        mask(max(1, k_obs-win_size):min(length(y_power), k_obs+win_size)) = false;
        
        P_background = var(y_total(mask)); % 或者使用 mean(y_power(mask))
        
        snr_post_measured = P_peak / P_background;
        % snr_sig(i) = 10*log10(snr_post_measured);
        % 
        % % 5. 计算等效脉冲压缩增益 (对比实测与脉压前)
        % m_pc_eq(i) = snr_post_measured / snr_pre;
    
        %% -------- 距离估计误差（修正匹配滤波中心偏移） --------
        mag = abs(y_total);
        [~, k_obs] = max(mag);
    
        if k_obs > 1 && k_obs < length(mag)
            y1 = mag(k_obs-1);
            y2 = mag(k_obs);
            y3 = mag(k_obs+1);
            delta = 0.5 * (y1 - y3) / (y1 - 2*y2 + y3);  % 抛物线插值
        else
            delta = 0;
        end
    
        % 峰值对应延时
        tau_est = ((k_obs + delta) - (N - 1)) / fs;
        R_est = c * tau_est / 2;
        % R_err(i) = R_est - R0;
    
        snr_sig_pre_acc  = snr_sig_pre_acc  + 10*log10(snr_pre);
        snr_sig_post_acc = snr_sig_post_acc + 10*log10(snr_post_measured);
        m_pc_eq_acc      = m_pc_eq_acc      + (snr_post_measured / snr_pre);
        R_err_acc        = R_err_acc        + (R_est - R0);
    end
    
    snr_sig_pre(i) = snr_sig_pre_acc / MC;
    snr_sig(i)     = snr_sig_post_acc / MC;
    m_pc_eq(i)     = m_pc_eq_acc / MC;
    R_err(i)       = R_err_acc / MC;

    %% -------- 功能级 SNR --------
    snr_func(i) = 10*log10(Pr*B*T/Pn);
end

%% ================= 探测失效点 =================
rel_err = abs(R_err) ./ R_list;

% 找到首个超过 2% 的点
idx_fail = find(abs(R_err) > 20, 1, 'first');

if isempty(idx_fail)
    fprintf('未检测到探测失效点（误差始终小于 2%%）\n');
    R_fail   = NaN;
    snr_fail = NaN;
else
    R_fail   = R_list(idx_fail);
    snr_fail = snr_sig(idx_fail);

    fprintf('探测失效点检测结果：\n');
    fprintf('  距离 = %.2f m\n', R_fail);
    fprintf('  信号级 SNR = %.2f dB\n', snr_fail);
    fprintf('  距离误差 = %.2f m (%.2f%%)\n', ...
            R_err(idx_fail), 100*rel_err(idx_fail));
end

%% ================= 图 1：脉冲压缩增益 (同步失效点) =================
figure;
plot(R_list, 10*log10(m_pc_eq), 'b.-', 'LineWidth', 1.5); hold on;
yline(10*log10(B*T), 'r--', 'LineWidth', 1.5);

% 绘制失效点垂直线
if ~isnan(R_fail)
    h_fail1 = xline(R_fail, 'r--', 'LabelVerticalAlignment', 'bottom', 'LineWidth', 1.5);
    % 在曲线上标记具体点
    idx_f = find(R_list >= R_fail, 1, 'first');
    scatter(R_list(idx_f), 10*log10(m_pc_eq(idx_f)), 80, 'filled', 'MarkerFaceColor', 'r');
end

xlabel('距离 (m)');
ylabel('脉冲压缩增益 (dB)');
legend('信号级反推', '理论 BT', '探测失效阈值');
title('等效脉冲压缩增益 vs 距离');
grid on;

%% ================= 图 2：SNR 对比 (同步失效点) =================
figure; hold on;
plot(R_list, snr_sig_pre,  'g--.', 'LineWidth', 1.5);
plot(R_list, snr_func_pre, 'b:',    'LineWidth', 1.5);
plot(R_list, snr_sig,      'r-',    'LineWidth', 1.5);
plot(R_list, snr_func,     'k--',   'LineWidth', 1.5);

% 绘制失效点垂直线
if ~isnan(R_fail)
    h_fail2 = xline(R_fail, 'r--', 'LabelHorizontalAlignment', 'left', 'LineWidth', 1.5);
    
    % 找到失效点对应的信号级 SNR 值并标注
    idx_f = find(R_list >= R_fail, 1, 'first');
    snr_at_fail = snr_sig(idx_f);
    scatter(R_fail, snr_at_fail, 60, 'r', 'filled');
    text(R_fail + 100, snr_at_fail, sprintf('SNR_{fail} = %.1f dB', snr_at_fail), 'Color', 'r', 'FontWeight', 'bold');
end

xlabel('距离 (m)');
ylabel('SNR (dB)');
legend({'SNR_{signal, pre-PC}', 'SNR_{functional, pre-PC}', 'SNR_{signal, post-PC}', 'SNR_{functional, post-PC}', '探测失效点'}, 'Location', 'best');
title('信号级与功能级 SNR 对比 (含失效点标注)');
grid on;


%% ================= 图 3：距离探测偏差 =================
figure;
h1 = plot(R_list, R_err, 'b.-','LineWidth',1.5); hold on;

if ~isnan(R_fail)
    h2 = xline(R_fail, 'r--','LineWidth',1.5);
    legend([h1 h2], {'距离误差','探测失效点 (2%)'}, 'Location','best');
else
    legend(h1, {'距离误差'}, 'Location','best');
end

xlabel('距离 (m)');
ylabel('距离估计误差 (m)');
title('脉冲压缩后距离探测偏差（2% 判据）');
grid on;

%% ================= 图 4：匹配滤波前后时域波形 =================
figure;

% 匹配滤波前
subplot(2,1,1);
plot(t*1e6, abs(s_rx_clean), 'b', 'LineWidth', 1.5);
xlabel('时间 (μs)');
ylabel('|s_{rx}(t)|');
title('匹配滤波前');
grid on;

% 匹配滤波后
t_y = (0:length(y_sig)-1)/fs;
subplot(2,1,2);
plot(t_y*1e6, abs(y_sig), 'r', 'LineWidth', 1.5);
xlabel('时间 (μs)');
ylabel('|y(t)|');
title('匹配滤波后');
grid on;

%% ================= 图 5：特定距离匹配滤波时域波形（含主瓣标记） =================
figure; hold on;

R_plot = [300,400 3300];
colors = {'b', 'r'};
labels = {};

for j = 1:length(R_plot)

    R0 = R_plot(j);
    tau = 2*R0/c;

    % 回波信号
    t_eff = t - tau;
    valid = (t_eff >= 0) & (t_eff <= T);
    s_rx_clean = zeros(size(t));
    s_rx_clean(valid) = exp(1j*pi*u*t_eff(valid).^2);

    % 雷达方程
    Pr = (Pt*Gt*Gr*lambda^2*sigma)/((4*pi)^3*R0^4*Lsys);
    s_rx_clean = sqrt(Pr)*s_rx_clean;

    % 加噪
    Pn = k*T0*B_rx*NF;
    noise = sqrt(Pn/2)*(randn(size(t)) + 1j*randn(size(t)));

    % 匹配滤波
    y_sig = conv(s_rx_clean + noise, h, 'full');
    t_y = (0:length(y_sig)-1)/fs;

    mag = abs(y_sig);

    % 找主瓣峰值
    [~, k_obs] = max(mag);

    % 主瓣范围
    win_size = round(fs/B * 5);
    k_left  = max(1, k_obs-win_size);
    k_right = min(length(mag), k_obs+win_size);

    % 绘图
    plot(t_y*1e6, mag, 'Color', colors{j}, 'LineWidth', 1.5);
    labels{end+1} = sprintf('R = %d m', R0);

    % 主瓣区域标记（半透明阴影）
    x_fill = t_y([k_left k_right k_right k_left])*1e6;
    y_fill = [0 0 max(mag) max(mag)];

    fill(x_fill, y_fill, colors{j}, ...
        'FaceAlpha', 0.08, ...
        'EdgeColor', 'none');

    % 主瓣边界线
    xline(t_y(k_left)*1e6,  '--', 'Color', colors{j});
    xline(t_y(k_right)*1e6, '--', 'Color', colors{j});

    % 标注峰值点
    plot(t_y(k_obs)*1e6, mag(k_obs), 'o', ...
        'Color', colors{j}, 'MarkerFaceColor', colors{j});

end

xlabel('时间 (\mus)');
ylabel('|y(t)|');
title('匹配滤波后时域波形（含主瓣判定范围）');
legend(labels, 'Location','best');
grid on;




